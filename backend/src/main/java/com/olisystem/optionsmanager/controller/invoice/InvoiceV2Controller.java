package com.olisystem.optionsmanager.controller.invoice;

import com.olisystem.optionsmanager.dto.invoice.*;
import com.olisystem.optionsmanager.model.auth.User;
import com.olisystem.optionsmanager.model.enums.InvoiceProcessingStatus;
import com.olisystem.optionsmanager.service.invoice.InvoiceImportService;
import com.olisystem.optionsmanager.service.invoice.InvoiceQueryService;
import com.olisystem.optionsmanager.service.auth.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

/**
 * Controller para importa√ß√£o e consulta de notas de corretagem
 * Novo sistema de importa√ß√£o (Fase 1)
 * ‚úÖ ATUALIZADO: Suporte a filtro por status de processamento
 */
@RestController
@RequestMapping("/api/invoices-v2")
@RequiredArgsConstructor
@Slf4j
public class InvoiceV2Controller {

    private final InvoiceImportService invoiceImportService;
    private final InvoiceQueryService invoiceQueryService;
    private final UserService userService;

    /**
     * Importa m√∫ltiplas notas de corretagem
     * POST /api/invoices/import
     */
    @PostMapping("/import")
    public ResponseEntity<InvoiceImportResponse> importInvoices(
            @Valid @RequestBody InvoiceImportRequest request,
            Authentication authentication) {
        
        log.info("=== RECEBENDO REQUEST DE IMPORTA√á√ÉO ===");
        log.info("Usu√°rio: {}, Corretora: {}, Arquivos: {}", 
                 authentication.getName(), request.brokerageId(), request.files().size());

        try {
            // Obter usu√°rio autenticado
            User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
            
            // Processar importa√ß√£o
            InvoiceImportResponse response = invoiceImportService.importInvoices(request, user);
            
            log.info("‚úÖ Importa√ß√£o conclu√≠da - Sucessos: {}, Erros: {}", 
                     response.successfulImports(), response.failedImports());
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("‚ùå Erro na importa√ß√£o: {}", e.getMessage(), e);
            
            InvoiceImportResponse errorResponse = new InvoiceImportResponse(
                "Erro na importa√ß√£o: " + e.getMessage(),
                request.files().size(),
                0,
                0,
                request.files().size(),
                java.time.LocalDateTime.now(),
                List.of()
            );
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    /**
     * Lista notas com filtros e pagina√ß√£o
     * GET /api/invoices-v2?page=0&size=1000&processingStatus=PENDING
     * ‚úÖ ATUALIZADO: Suporte a filtro por status de processamento
     */
    @GetMapping
    public ResponseEntity<Page<InvoiceData>> getInvoices(
            @RequestParam(required = false) UUID brokerageId,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
            @RequestParam(required = false) String invoiceNumber,
            @RequestParam(required = false) String clientName,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate importStartDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate importEndDate,
            @RequestParam(required = false) String processingStatus, // ‚úÖ NOVO: Status de processamento
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDirection,
            Authentication authentication) {
        
        log.info("üìã Buscando invoices com filtros - Status: {}, Page: {}, Size: {}", 
            processingStatus, page, size);
        
        User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
        
        InvoiceFilterRequest filterRequest = new InvoiceFilterRequest(
            brokerageId,
            startDate,
            endDate,
            invoiceNumber,
            clientName,
            importStartDate,
            importEndDate,
            processingStatus, // ‚úÖ NOVO: Status de processamento
            page,
            size,
            sortBy,
            sortDirection
        );
        
        // ‚úÖ NOVO: Usar m√©todo com suporte ao filtro ALL
        Page<InvoiceData> invoices = invoiceQueryService.findInvoicesWithProcessingStatusFilter(filterRequest, user);
        
        log.info("‚úÖ Encontradas {} invoices", invoices.getTotalElements());
        return ResponseEntity.ok(invoices);
    }

    /**
     * Busca nota espec√≠fica por ID
     * GET /api/invoices/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<InvoiceData> getInvoiceById(
            @PathVariable UUID id,
            Authentication authentication) {
        
        log.debug("Buscando nota {} para usu√°rio {}", id, authentication.getName());

        try {
            // Obter usu√°rio autenticado
            User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
            
            // Buscar nota
            return invoiceQueryService.findInvoiceById(id, user)
                .map(invoice -> {
                    log.debug("‚úÖ Nota encontrada: {}", invoice.invoiceNumber());
                    return ResponseEntity.ok(invoice);
                })
                .orElseGet(() -> {
                    log.warn("‚ùå Nota {} n√£o encontrada", id);
                    return ResponseEntity.notFound().build();
                });
                
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar nota {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Lista notas por corretora
     * GET /api/invoices/brokerage/{brokerageId}
     */
    @GetMapping("/brokerage/{brokerageId}")
    public ResponseEntity<Page<InvoiceData>> getInvoicesByBrokerage(
            @PathVariable UUID brokerageId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            Authentication authentication) {
        
        log.debug("Buscando notas da corretora {} para usu√°rio {}", brokerageId, authentication.getName());

        try {
            // Obter usu√°rio autenticado
            User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
            
            // Buscar notas
            Page<InvoiceData> invoices = invoiceQueryService.findInvoicesByBrokerage(brokerageId, user, page, size);
            
            log.debug("‚úÖ Encontradas {} notas da corretora", invoices.getNumberOfElements());
            
            return ResponseEntity.ok(invoices);
            
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar notas da corretora {}: {}", brokerageId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Busca √∫ltimas notas importadas
     * GET /api/invoices/latest
     */
    @GetMapping("/latest")
    public ResponseEntity<List<InvoiceData>> getLatestInvoices(
            @RequestParam(defaultValue = "10") int limit,
            Authentication authentication) {
        
        log.debug("Buscando √∫ltimas {} notas para usu√°rio {}", limit, authentication.getName());

        try {
            // Obter usu√°rio autenticado
            User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
            
            // Buscar √∫ltimas notas
            List<InvoiceData> invoices = invoiceQueryService.findLatestImportedInvoices(user, limit);
            
            log.debug("‚úÖ Encontradas {} notas recentes", invoices.size());
            
            return ResponseEntity.ok(invoices);
            
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar √∫ltimas notas: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Conta total de notas do usu√°rio
     * GET /api/invoices/count
     * ‚úÖ ATUALIZADO: Conta apenas notas n√£o processadas por padr√£o
     */
    @GetMapping("/count")
    public ResponseEntity<Long> countInvoices(Authentication authentication) {
        
        try {
            // Obter usu√°rio autenticado
            User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
            
            // Contar notas n√£o processadas
            Long count = invoiceQueryService.countInvoicesByUser(user);
            
            log.debug("‚úÖ Usu√°rio {} possui {} notas n√£o processadas", authentication.getName(), count);
            
            return ResponseEntity.ok(count);
            
        } catch (Exception e) {
            log.error("‚ùå Erro ao contar notas: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * ‚úÖ NOVO: Conta notas pendentes do usu√°rio
     * GET /api/invoices-v2/count/pending
     */
    @GetMapping("/count/pending")
    public ResponseEntity<Long> countPendingInvoices(Authentication authentication) {
        
        try {
            // Obter usu√°rio autenticado
            User user = userService.findByUsername(authentication.getName())
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));
            
            // Contar notas pendentes
            Long count = invoiceQueryService.countPendingInvoicesByUser(user);
            
            log.debug("‚úÖ Usu√°rio {} possui {} notas pendentes", authentication.getName(), count);
            
            return ResponseEntity.ok(count);
            
        } catch (Exception e) {
            log.error("‚ùå Erro ao contar notas pendentes: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
